export declare class CapmonsterClient {
    clientKey: string;
    private static hostUrl;
    private static balanceUrl;
    private static createTaskUrl;
    private static taskResultUrl;
    private callbackUrl?;
    private request;
    private timeout;
    constructor(clientKey: string);
    getBalance: () => Promise<number>;
    convertCookies: (cookies: {
        [key: string]: string | number | boolean;
    }) => string;
    setCallbackUrl: (url: string) => void;
    unsetCallbackUrl: () => void;
    setTimeout: (timeout: number) => void;
    protected _createTask: <T extends ITask>(task: T) => Promise<number>;
    protected _getTaskResult: <T extends ITaskSolution>(taskId: number) => Promise<T | null>;
    protected _joinTaskResult: <T extends ITaskSolution>(taskId: number, timeout?: number) => Promise<T>;
    protected addCookies: (cookies: string | Array<unknown> | object) => string;
    protected isReady: <K extends ITaskSolution, T extends WithRequired<ITaskResponse<K>, "status">>(response: T) => response is WithRequired<T, "solution">;
    private timer;
    private checkResponse;
}
export declare class UAProxy extends CapmonsterClient {
    protected proxy: IProxyTaskRequest;
    protected userAgent: IUserAgentTaskRequest;
    constructor(clientKey: string);
    setUserAgent: (userAgent: string) => void;
    resetUserAgent: () => void;
    unsetUserAgent: () => void;
    setProxy: (proxyType: ProxyType, proxyAddress: string, proxyPort: number, proxyLogin?: string, proxyPassword?: string) => void;
    setGlobalProxy: (proxy: WithRequired<IProxyTaskRequest, "proxyType" | "proxyAddress" | "proxyPort">) => WithRequired<IProxyTaskRequest, "proxyType" | "proxyAddress" | "proxyPort">;
    disableProxy: () => void;
    unsetProxy: () => void;
    protected isUserAgentTask: <T extends ITask>(data: T) => [T | (T & IUserAgentTaskRequest), boolean];
    protected isProxyTask: <T extends ITask>(data: T) => [T | (T & IProxyTaskRequest), boolean];
}
type WithRequired<T, K extends keyof T> = T & {
    [P in K]-?: T[P];
};
type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export interface IErrorResponse {
    errorId: number;
    errorCode?: string;
    errorDescription?: string;
}
export interface IRequest {
    clientKey: string;
    callbackUrl: string;
    taskId: number;
}
export interface ITaskRequest<T extends ITask> extends PartialBy<Pick<IRequest, "clientKey" | "callbackUrl">, "callbackUrl"> {
    task: T;
}
export interface ITask {
    type: string;
}
export interface IUserAgentTaskRequest {
    userAgent?: string;
}
export type ProxyType = "http" | "https" | "socks4" | "socks5";
export interface IProxyTaskRequest {
    proxyType?: ProxyType;
    proxyAddress?: string;
    proxyPort?: number;
    proxyLogin?: string;
    proxyPassword?: string;
}
export interface ITaskSolution {
}
export interface ITaskResponse<T extends ITaskSolution> extends IErrorResponse, Pick<IResponse, "status"> {
    solution?: T;
}
export interface IResponse extends IErrorResponse {
    balance?: number;
    taskId?: number;
    status?: "processing" | "ready";
}
export type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> & {
    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;
}[Keys];
export {};
//# sourceMappingURL=capmonster.d.ts.map