"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UAProxy = exports.CapmonsterClient = void 0;
const axios_1 = __importDefault(require("axios"));
const capmonster_error_1 = require("./capmonster_error");
class CapmonsterClient {
    clientKey;
    static hostUrl = "https://api.capmonster.cloud";
    static balanceUrl = "/getBalance";
    static createTaskUrl = "/createTask";
    static taskResultUrl = "/getTaskResult";
    callbackUrl;
    request;
    timeout = 120;
    constructor(clientKey) {
        this.clientKey = clientKey;
        this.request = axios_1.default.create({
            baseURL: CapmonsterClient.hostUrl,
            validateStatus: (status) => {
                return ((status >= 200 && status < 300) ||
                    (status >= 400 && status < 500));
            },
        });
    }
    getBalance = async () => {
        const requestData = {
            clientKey: this.clientKey,
        };
        const response = await this.request.post(CapmonsterClient.balanceUrl, requestData);
        this.checkResponse(response.data);
        return response.data
            .balance;
    };
    convertCookies = (cookies) => {
        let _cookies = "";
        for (const [key, value] of Object.entries(cookies)) {
            _cookies += `${key}=${value};`;
        }
        return _cookies.slice(0, -1);
    };
    setCallbackUrl = (url) => {
        this.callbackUrl = url;
    };
    unsetCallbackUrl = () => (this.callbackUrl = undefined);
    setTimeout = (timeout) => {
        if (timeout > 0 && timeout <= 300)
            this.timeout = timeout;
    };
    _createTask = async (task) => {
        const realData = {
            softId: 32,
            task,
            callbackUrl: this.callbackUrl,
            clientKey: this.clientKey,
        };
        const { data: d } = await this.request.post(CapmonsterClient.createTaskUrl, realData);
        this.checkResponse(d);
        return d.taskId;
    };
    _getTaskResult = async (taskId) => {
        const requestData = {
            clientKey: this.clientKey,
            taskId: taskId,
        };
        const { data } = await this.request.post(CapmonsterClient.taskResultUrl, requestData);
        this.checkResponse(data);
        return this.isReady(data) ? data.solution : null;
    };
    _joinTaskResult = async (taskId, timeout) => {
        const _timeout = timeout && timeout <= 300 && timeout > 0 ? timeout : this.timeout;
        for (let i = 0; i <= _timeout + 1; i += 2) {
            const result = await this._getTaskResult(taskId);
            if (result !== null)
                return result;
            await this.timer(2000);
        }
        throw new capmonster_error_1.CapmonsterError({
            errorId: -1,
            errorCode: "ERROR_MAXIMUM_TIME_EXCEED",
            errorDescription: "Maximum time is exceed",
        });
    };
    addCookies = (cookies) => {
        let str_cookies = "";
        if (typeof cookies === "string") {
            str_cookies = cookies;
        }
        else if (Array.isArray(cookies)) {
            if (cookies.length % 2 != 0)
                throw Error("Array cookies length must be even numbers");
            cookies.forEach((v, i) => {
                str_cookies += i % 2 == 0 ? `${v}=` : `${v};`;
            });
        }
        else if (typeof cookies === "object") {
            for (const [key, value] of Object.entries(cookies)) {
                str_cookies += `${key}=${value};`;
            }
        }
        return str_cookies.slice(-1) == ";"
            ? str_cookies.slice(0, -1)
            : str_cookies;
    };
    isReady = (response) => response.status === "ready";
    timer = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    checkResponse = (response) => {
        if (response.errorId === 0)
            return;
        throw new capmonster_error_1.CapmonsterError(response);
    };
}
exports.CapmonsterClient = CapmonsterClient;
class UAProxy extends CapmonsterClient {
    proxy = {};
    userAgent = {};
    constructor(clientKey) {
        super(clientKey);
    }
    setUserAgent = (userAgent) => {
        this.userAgent = {
            userAgent,
        };
    };
    resetUserAgent = () => {
        console.warn("This function is deprecated, use `unsetUserAgent` to avoid errors in future versions");
        this.userAgent = {};
    };
    unsetUserAgent = () => {
        this.userAgent = {};
    };
    setProxy = (proxyType, proxyAddress, proxyPort, proxyLogin, proxyPassword) => {
        console.warn("This function is deprecated, use `setGlobalProxy` to avoid errors in future versions");
        this.proxy = {
            proxyType,
            proxyPort,
            proxyAddress,
            proxyLogin,
            proxyPassword,
        };
    };
    setGlobalProxy = (proxy) => (this.proxy = proxy);
    disableProxy = () => {
        console.warn("This function is deprecated, use `resetProxy` to avoid errors in future versions");
        this.proxy = {};
    };
    unsetProxy = () => {
        this.proxy = {};
    };
    isUserAgentTask = (data) => {
        if (this.userAgent.userAgent !== undefined) {
            const dataWithUserAgent = {
                ...data,
                ...this.userAgent,
            };
            return [dataWithUserAgent, true];
        }
        return [data, false];
    };
    isProxyTask = (data) => {
        if (this.proxy.proxyType !== undefined &&
            this.proxy.proxyAddress !== undefined &&
            this.proxy.proxyPort !== undefined) {
            const dataWithProxy = {
                ...data,
                ...this.proxy,
            };
            return [dataWithProxy, true];
        }
        const d = data;
        d.type += "Proxyless";
        return [d, false];
    };
}
exports.UAProxy = UAProxy;
